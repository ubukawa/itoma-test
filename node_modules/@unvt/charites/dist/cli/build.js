"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const build_1 = require("../commands/build");
const error_1 = require("../lib/error");
const defaultValues_1 = require("../lib/defaultValues");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const program = new commander_1.Command();
program
    .name('build')
    .arguments('<source> [destination]')
    .description('build a style JSON from the YAML')
    .option('-c, --compact-output', 'build a minified style JSON')
    .option('-w, --watch', 'watch YAML and build when changed')
    .option('-u, --sprite-url [<sprite url>]', 'url to set as the sprite in style.json')
    .option('-i, --sprite-input [<icon input directory>]', 'directory path of icon source to build icons. The default <icon source> is `icons/`')
    .option('-o, --sprite-output [<icon output directory>]', 'directory path to output icon files. The default <icons destination> is the current directory')
    .option('--provider [provider]', 'your map service. e.g. `mapbox`, `geolonia`')
    .action(async (source, destination, buildOptions) => {
    const options = program.opts();
    options.provider = buildOptions.provider;
    options.compactOutput = buildOptions.compactOutput;
    options.spriteUrl = buildOptions.spriteUrl;
    options.spriteOutput = buildOptions.spriteOutput || process.cwd();
    const spriteInputDefault = path_1.default.resolve(process.cwd(), 'icons');
    if (buildOptions.spriteInput) {
        options.spriteInput = buildOptions.spriteInput;
    }
    else if (fs_1.default.existsSync(spriteInputDefault)) {
        options.spriteInput = spriteInputDefault;
    }
    if (!fs_1.default.existsSync(defaultValues_1.defaultSettings.configFile)) {
        fs_1.default.writeFileSync(defaultValues_1.defaultSettings.configFile, `provider: ${options.provider || 'default'}`);
    }
    if (buildOptions.watch) {
        try {
            console.log('Start watching...');
            await new Promise((resolve) => {
                const watcher = build_1.buildWatch(source, destination, options);
                process.on('SIGINT', () => {
                    watcher.close();
                    resolve(undefined);
                });
            });
        }
        catch (e) {
            error_1.error(e);
        }
    }
    else {
        try {
            await build_1.build(source, destination, options);
        }
        catch (e) {
            error_1.error(e);
        }
    }
});
exports.default = program;
